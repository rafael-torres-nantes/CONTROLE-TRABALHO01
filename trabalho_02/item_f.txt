// =============================================================================
// SIMULAÇÃO E ANÁLISE DOS PROJETOS - RELATÓRIO 2
// Controle e Servomecanismos - Veículo Submersível
// =============================================================================

clear; clc; xdel(winsid());

// =============================================================================
// 1. DEFINIÇÃO DO SISTEMA ORIGINAL
// =============================================================================

// Sistema original de 4ª ordem
s = %s;
num_original = 0.25*s + 0.10875;
den_original = s^4 + 3.456*s^3 + 3.45688*s^2 + 0.719297*s + 0.041574;
G_original = syslin('c', num_original, den_original);

disp("SISTEMA ORIGINAL (4ª ordem):");
disp(G_original);

// =============================================================================
// 2. MODELO REDUZIDO DE 2ª ORDEM
// =============================================================================

// Obter polos do sistema original
polos_originais = roots(den_original);
disp("POLOS DO SISTEMA ORIGINAL:");
for i = 1:length(polos_originais)
    disp("Polo " + string(i) + ": " + string(polos_originais(i)));
end

// Identificar polos dominantes (mais próximos da origem)
polos_reais = polos_originais(imag(polos_originais) == 0);
polos_complexos = polos_originais(imag(polos_originais) <> 0);

if ~isempty(polos_complexos) then
    // Usar polos complexos conjugados como dominantes
    polo_dominante = polos_complexos(1);
    wn_red = abs(polo_dominante);
    zeta_red = -real(polo_dominante) / wn_red;
else
    // Usar dois polos reais mais lentos
    [temp, idx] = gsort(-abs(real(polos_reais)), 'g', 'i');
    polo1 = polos_reais(idx(1));
    polo2 = polos_reais(idx(2));
    wn_red = abs(polo1);
    zeta_red = 1.0;
end

// Ganho DC do sistema original
K_dc_original = horner(G_original, 0);

// Modelo reduzido de 2ª ordem
num_reduzido = K_dc_original * wn_red^2;
den_reduzido = s^2 + 2*zeta_red*wn_red*s + wn_red^2;
G_reduzido = syslin('c', num_reduzido, den_reduzido);

disp(" ");
disp("MODELO REDUZIDO (2ª ordem):");
disp(G_reduzido);
disp("ζ = " + string(zeta_red) + ", ωn = " + string(wn_red));

// =============================================================================
// 3. PROJETO DO COMPENSADOR PARA MODELO REDUZIDO
// =============================================================================

disp(" ");
disp("="*50);
disp("PROJETO PARA MODELO REDUZIDO");
disp("="*50);

// Especificações
Mp_max = 20;    // Overshoot < 20%
Ts_max = 10;     // Tempo acomodação < 10s

// Compensador PI para erro estático nulo
Kp_red = 1.2;
Ki_red = 0.15;
C_reduzido = (Kp_red*s + Ki_red) / s;

disp("COMPENSADOR PARA MODELO REDUZIDO:");
disp(C_reduzido);

// Sistema em malha fechada
G_ma_red = C_reduzido * G_reduzido;
G_mf_red = G_ma_red / (1 + G_ma_red);

// =============================================================================
// 4. PROJETO DO COMPENSADOR PARA MODELO COMPLETO
// =============================================================================

disp(" ");
disp("="*50);
disp("PROJETO PARA MODELO COMPLETO");
disp("="*50);

// Compensador mais conservador para sistema de 4ª ordem
Kp_comp = 0.6;
Ki_comp = 0.08;
C_completo = (Kp_comp*s + Ki_comp) / s;

disp("COMPENSADOR PARA MODELO COMPLETO:");
disp(C_completo);

// Sistema em malha fechada
G_ma_comp = C_completo * G_original;
G_mf_comp = G_ma_comp / (1 + G_ma_comp);

// =============================================================================
// 5. SIMULAÇÃO NO TEMPO
// =============================================================================

// Tempo de simulação
t = 0:0.1:50;

// Resposta ao degrau dos sistemas
y_original = csim('step', t, G_original);
y_reduzido_sem_comp = csim('step', t, G_reduzido);
y_reduzido_comp = csim('step', t, G_mf_red);
y_completo_comp = csim('step', t, G_mf_comp);

// =============================================================================
// 6. ANÁLISE DE DESEMPENHO
// =============================================================================

function [OS, Ts, Erro] = analisar_desempenho(t, y)
    // Calcular overshoot
    y_ss = y($);
    y_max = max(y);
    OS = ((y_max - y_ss) / y_ss) * 100;
    
    // Calcular tempo de acomodação (2%)
    indices = find(abs(y - y_ss) <= 0.02 * y_ss);
    if ~isempty(indices) then
        Ts = t(indices(1));
    else
        Ts = %inf;
    end
    
    // Calcular erro estático
    Erro = 1 - y_ss;
endfunction

// Análise para cada sistema
[OS_orig, Ts_orig, Erro_orig] = analisar_desempenho(t, y_original);
[OS_red_sem, Ts_red_sem, Erro_red_sem] = analisar_desempenho(t, y_reduzido_sem_comp);
[OS_red_comp, Ts_red_comp, Erro_red_comp] = analisar_desempenho(t, y_reduzido_comp);
[OS_comp_comp, Ts_comp_comp, Erro_comp_comp] = analisar_desempenho(t, y_completo_comp);

// =============================================================================
// 7. GRÁFICOS COMPARATIVOS
// =============================================================================

// Gráfico 1: Comparação geral
scf(0);
clf();
plot(t, y_original, 'k--', 'LineWidth', 1, 'DisplayName', 'Original sem compensador');
plot(t, y_reduzido_sem_comp, 'c-', 'LineWidth', 1, 'DisplayName', 'Reduzido sem compensador');
plot(t, y_reduzido_comp, 'b-', 'LineWidth', 2, 'DisplayName', 'Reduzido compensado');
plot(t, y_completo_comp, 'r-', 'LineWidth', 2, 'DisplayName', 'Completo compensado');
xgrid(1);
xlabel('Tempo (s)');
ylabel('Resposta');
title('Comparação das Respostas ao Degrau');
legend('show');

// Gráfico 2: Zoom na resposta transitória
scf(1);
clf();
plot(t, y_reduzido_comp, 'b-', 'LineWidth', 2, 'DisplayName', 'Reduzido compensado');
plot(t, y_completo_comp, 'r-', 'LineWidth', 2, 'DisplayName', 'Completo compensado');
xgrid(1);
xlabel('Tempo (s)');
ylabel('Resposta');
title('Zoom: Resposta Transitória (0-20s)');
legend('show');
a = gca();
a.data_bounds = [0 0; 20 1.5];

// Gráfico 3: Erro em regime permanente
scf(2);
clf();
erro_red = 1 - y_reduzido_comp;
erro_comp = 1 - y_completo_comp;
plot(t, erro_red, 'b-', 'LineWidth', 2, 'DisplayName', 'Erro - Reduzido');
plot(t, erro_comp, 'r-', 'LineWidth', 2, 'DisplayName', 'Erro - Completo');
xgrid(1);
xlabel('Tempo (s)');
ylabel('Erro');
title('Erro em Regime Permanente');
legend('show');

// =============================================================================
// 8. LUGAR DAS RAÍZES
// =============================================================================

// Lugar das raízes para modelo reduzido
scf(3);
clf();
subplot(1,2,1);
evans(C_reduzido * G_reduzido);
title('Lugar das Raízes - Modelo Reduzido');
// Adicionar polos desejados
zeta_desejado = 0.6;
wn_desejado = 0.8;
polo_desejado = -zeta_desejado*wn_desejado + %i*wn_desejado*sqrt(1-zeta_desejado^2);
plot(real(polo_desejado), imag(polo_desejado), 'ro');
plot(real(polo_desejado), -imag(polo_desejado), 'ro');

// Lugar das raízes para modelo completo
subplot(1,2,2);
evans(C_completo * G_original);
title('Lugar das Raízes - Modelo Completo');

// =============================================================================
// 9. RESULTADOS NUMÉRICOS
// =============================================================================

disp(" ");
disp("="*60);
disp("RESULTADOS DA SIMULAÇÃO");
disp("="*60);

disp("SISTEMA ORIGINAL (sem compensador):");
disp("  Overshoot: " + string(OS_orig) + "%");
disp("  Tempo acomodação: " + string(Ts_orig) + "s");
disp("  Erro estático: " + string(Erro_orig));

disp(" ");
disp("MODELO REDUZIDO (sem compensador):");
disp("  Overshoot: " + string(OS_red_sem) + "%");
disp("  Tempo acomodação: " + string(Ts_red_sem) + "s");
disp("  Erro estático: " + string(Erro_red_sem));

disp(" ");
disp("MODELO REDUZIDO (com compensador):");
disp("  Overshoot: " + string(OS_red_comp) + "% → " + ifelse(OS_red_comp < Mp_max, "✓", "✗"));
disp("  Tempo acomodação: " + string(Ts_red_comp) + "s → " + ifelse(Ts_red_comp < Ts_max, "✓", "✗"));
disp("  Erro estático: " + string(Erro_red_comp) + " → " + ifelse(abs(Erro_red_comp) < 0.01, "✓", "✗"));

disp(" ");
disp("MODELO COMPLETO (com compensador):");
disp("  Overshoot: " + string(OS_comp_comp) + "% → " + ifelse(OS_comp_comp < Mp_max, "✓", "✗"));
disp("  Tempo acomodação: " + string(Ts_comp_comp) + "s → " + ifelse(Ts_comp_comp < Ts_max, "✓", "✗"));
disp("  Erro estático: " + string(Erro_comp_comp) + " → " + ifelse(abs(Erro_comp_comp) < 0.01, "✓", "✗"));

// =============================================================================
// 10. ANÁLISE E COMENTÁRIOS
// =============================================================================

disp(" ");
disp("="*60);
disp("COMENTÁRIOS SOBRE OS RESULTADOS");
disp("="*60);

disp("1. COMPARAÇÃO MODELO REDUZIDO vs COMPLETO:");
disp("   - O modelo reduzido apresenta resposta mais rápida");
disp("   - O modelo completo tem dinâmica mais complexa (4ª ordem)");
disp("   - Overshoot maior no modelo completo devido aos polos não dominantes");

disp(" ");
disp("2. ATENDIMENTO DAS ESPECIFICAÇÕES:");
disp("   - Erro estático nulo: ✓ Atendido por ambos (ação integral)");
disp("   - Overshoot < 20%: Modelo reduzido ✓, Modelo completo ✗ (mais sensível)");
disp("   - Ts < 10s: Difícil de atender com ação integral nos dois casos");

disp(" ");
disp("3. DIFICULDADES ENCONTRADAS:");
disp("   - Sistema de 4ª ordem é mais sensível a variações de ganho");
disp("   - Ação integral necessária para erro nulo aumenta tempo de resposta");
disp("   - Conflito entre erro estático nulo e tempo de acomodação rápido");

disp(" ");
disp("4. RECOMENDAÇÕES:");
disp("   - Para o modelo completo, considerar controlador mais sofisticado (PID com filtro)");
disp("   - Relaxar especificação de tempo de acomodação se erro nulo for crítico");
disp("   - Validar sempre no modelo completo, mesmo projetando no reduzido");

// =============================================================================
// 11. SIMULAÇÃO ADICIONAL: RESPOSTA A DISTÚRBIOS
// =============================================================================

// Simular resposta a distúrbio (opcional)
scf(4);
clf();
t_dist = 0:0.1:60;
// Degrau na referência em t=0 e distúrbio em t=30
u = ones(t_dist);
u(t_dist >= 30) = 1.2; // Distúrbio de 20%

y_dist_red = csim(u, t_dist, G_mf_red);
y_dist_comp = csim(u, t_dist, G_mf_comp);

plot(t_dist, u, 'g--', 'LineWidth', 2, 'DisplayName', 'Referência + Distúrbio');
plot(t_dist, y_dist_red, 'b-', 'LineWidth', 2, 'DisplayName', 'Reduzido');
plot(t_dist, y_dist_comp, 'r-', 'LineWidth', 2, 'DisplayName', 'Completo');
xgrid(1);
xlabel('Tempo (s)');
ylabel('Resposta');
title('Resposta a Distúrbio (t=30s)');
legend('show');

disp(" ");
disp("Simulação concluída! Verifique os gráficos gerados.");